{"version":3,"file":"honeycomb.esm.min.js","sources":["../node_modules/axis.js/dist/axis.js","../src/utils.js","../src/hex/statics.js","../src/hex/constants.js","../src/hex/prototype.js","../src/hex/index.js","../src/grid/statics.js","../src/grid/prototype.js","../src/grid/index.js","../src/point/prototype.js","../src/point/index.js","../src/grid/class.js","../src/honeycomb.js"],"sourcesContent":["/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n    return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n    return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n    if (!/^(N|S)?(E|W)?$/i.test(value)) {\n        throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n    }\n\n    orientation = orientation.toLowerCase()\n    value = value.toUpperCase()\n\n    if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n    }\n    if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n        throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n    }\n\n    /**\n     * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n     * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n     * and flat hexes don't have a west and east compass direction.\n     *\n     * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n     * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n     *\n     * @typedef {string} COMPASS_DIRECTION\n     *\n     * @readonly\n     * @enum {COMPASS_DIRECTION}\n     *\n     * @property {COMPASS_DIRECTION} E  â†’ east\n     * @property {COMPASS_DIRECTION} SE â†˜ southeast\n     * @property {COMPASS_DIRECTION} S  â†“ south\n     * @property {COMPASS_DIRECTION} SW â†™ southwest\n     * @property {COMPASS_DIRECTION} W  â† west\n     * @property {COMPASS_DIRECTION} NW â†– northwest\n     * @property {COMPASS_DIRECTION} N  â†‘ north\n     * @property {COMPASS_DIRECTION} NE â†— northeast\n     */\n    return {\n        pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n        flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 }\n    }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n    if (!isNumber(x) && !isNumber(y)) {\n        x = y = 0\n    } else if (!isNumber(x)) {\n        x = y\n    } else if (!isNumber(y)) {\n        y = x\n    }\n\n    return { x, y }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n    return -firstCoordinate - secondCoordinate\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n    { q: 1, r: 0 },\n    { q: 0, r: 1 },\n    { q: -1, r: 1 },\n    { q: -1, r: 0 },\n    { q: 0, r: -1 },\n    { q: 1, r: -1 }\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n    { q: 2, r: -1 },\n    { q: 1, r: 1 },\n    { q: -1, r: 2 },\n    { q: -2, r: 1 },\n    { q: -1, r: -1 },\n    { q: 1, r: -2 }\n]\n\nexport const EPSILON = { x: 1e-6, y: 1e-6 }\n","import { EPSILON } from './constants'\nimport { offsetFromZero } from '../utils'\n\nconst sqrt3 = Math.sqrt(3)\n\nexport function setFactory({ Hex }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n     * @returns {hex}           Itself with the passed parameters merged into it.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n     * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n     * hex === updatedHex                                   // true: hex is updated in-place\n     */\n    return function set(...args) {\n        return Object.assign(this, Hex(...args))\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n    return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n    return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n    let x, y\n\n    if (this.isPointy()) {\n        x = q + offsetFromZero(this.offset, r)\n        y = r\n    } else {\n        x = q\n        y = r + offsetFromZero(this.offset, q)\n    }\n\n    return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     *\n     * @todo make this a static (and instance?) method\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * const Point = Honeycomb.Point\n     *\n     * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n     * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n     */\n    return function cartesianToCube(pointOrX, y) {\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y))\n\n        if (this.isPointy()) {\n            q = x - offsetFromZero(this.offset, y)\n            r = y\n        } else {\n            q = x\n            r = y - offsetFromZero(this.offset, x)\n        }\n\n        return { q, r, s: -q - r }\n    }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy â¬¢ orientation.\n */\nexport function isPointy() {\n    return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat â¬£ orientation.\n */\nexport function isFlat() {\n    return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite corners of a hex.\n */\nexport function oppositeCornerDistance() {\n    return this.size * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The distance between opposite sides of a hex.\n */\nexport function oppositeSideDistance() {\n    return sqrt3 / 2 * this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n    return this.isPointy() ?\n        this.oppositeSideDistance() :\n        this.oppositeCornerDistance()\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n    return this.isPointy() ?\n        this.oppositeCornerDistance() :\n        this.oppositeSideDistance()\n}\n\nexport function cornersFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point[]}\n     * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n     * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n     *\n     * @example\n     * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n     * const Hex1 = Honeycomb.extendHex({ size: 30 })\n     * Hex1().corners() // [\n     *                  //    { x: 51.96152422706631, y: 15 },\n     *                  //    { x: 51.96152422706631, y: 45 },\n     *                  //    { x: 25.980762113533157, y: 60 },\n     *                  //    { x: 0, y: 45 },\n     *                  //    { x: 0, y: 15 },\n     *                  //    { x: 25.980762113533157, y: 0 }\n     *                  // ]\n     *\n     * // set the origin to a hex's center\n     * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n     * Hex2().corners() // [\n     *                  //    { x: 25.980762113533157, y: -15 },\n     *                  //    { x: 25.980762113533157, y: 15 },\n     *                  //    { x: 0, y: 30 },\n     *                  //    { x: -25.980762113533157, y: 15 },\n     *                  //    { x: -25.980762113533157, y: -15 },\n     *                  //    { x: 0, y: -30 }\n     *                  // ]\n     */\n    return function corners() {\n        const width = this.width()\n        const height = this.height()\n        const { x, y } = this.origin\n\n        if (this.isPointy()) {\n            return [\n                Point(width - x, height * 0.25 - y),\n                Point(width - x, height * 0.75 - y),\n                Point(width * 0.5 - x, height - y),\n                Point(0 - x, height * 0.75 - y),\n                Point(0 - x, height * 0.25 - y),\n                Point(width * 0.5 - x, 0 - y)\n            ]\n        } else {\n            return [\n                Point(width - x, height * 0.5 - y),\n                Point(width * 0.75 - x, height - y),\n                Point(width * 0.25 - x, height - y),\n                Point(0 - x, height * 0.5 - y),\n                Point(width * 0.25 - x, 0 - y),\n                Point(width * 0.75 - x, 0 - y)\n            ]\n        }\n    }\n}\n\nexport function centerFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n     * Note that the default origin is the top left corner, so the default center is\n     * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n     *\n     * @example\n     * const Hex1 = Honeycomb.extendHex({ size: 10 })\n     * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n     *\n     * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n     * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n     */\n    return function center() {\n        const { x, y } = this.origin\n        return Point(this.width() / 2 - x, this.height() / 2 - y)\n    }\n}\n\nexport function toPointFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     * @returns {point} The hex's origin point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 30 })\n     * Hex().toPoint()          // { x: 0, y: 0 }\n     * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n     */\n    return function toPoint() {\n        const { q, r, size } = this\n        let x, y\n\n        if (this.isPointy()) {\n            x = size * sqrt3 * (q + r / 2)\n            y = size * 3/2 * r\n        } else {\n            x = size * 3/2 * q\n            y = size * sqrt3 * (r + q / 2)\n        }\n\n        return Point(x, y)\n    }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n    /**\n     * Returns a hex from the passed {@link point}.\n     *\n     * @memberof Hex\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Point = Honeycomb.Point\n     * const hex = Hex()\n     *\n     * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n     * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n     * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function fromPoint(pointOrX, y) {\n        const { size } = this\n        let x, q, r\n\n        ({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n        if (this.isPointy()) {\n            q = (x * sqrt3 / 3 - y / 3) / size\n            r = y * 2 / 3 / size\n        } else {\n            q = x * 2 / 3 / size\n            r = (-x / 3 + sqrt3 / 3 * y) / size\n        }\n\n        return Hex({ q, r, s: -q - r }).round()\n    }\n}\n\nexport function addFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to add.\n     *\n     * @param {point} point The hex (or point) that will be added to the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n     *                      Any custom properties are copied.\n     */\n    return function add(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x + x, this.y + y, {...this})\n    }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @todo Accept any number of hexes to subtract.\n     *\n     * @param {point} point The hex (or point) that will be subtracted from the current.\n     * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n     *                      Any custom properties are copied.\n     */\n    return function subtract(point) {\n        const { x, y } = Point(point)\n        return Hex(this.x - x, this.y - y, {...this})\n    }\n}\n\nexport function equalsFactory({ Point }) {\n    /**\n     * @memberof Hex#\n     * @instance\n     *\n     * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n     * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n     */\n    return function equals(point) {\n        const { x, y } = Point(point)\n        return this.x === x && this.y === y\n    }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n    return Math.max(\n        Math.abs(this.q - hex.q),\n        Math.abs(this.r - hex.r),\n        Math.abs(this.s - hex.s)\n    )\n}\n\nexport function roundFactory({ Hex }) {\n    /**\n     * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n     *\n     * @memberof Hex#\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n     *\n     * @returns {hex}   A *new* hex with rounded coordinates.\n     *                  Any custom properties are copied.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n     */\n    return function round() {\n        let { q, r, s } = this\n        let roundedQ = Math.round(q)\n        let roundedR = Math.round(r)\n        let roundedS = Math.round(s)\n        const diffQ = Math.abs(q - roundedQ)\n        const diffR = Math.abs(r - roundedR)\n        const diffS = Math.abs(s - roundedS)\n\n        if (diffQ > diffR && diffQ > diffS) {\n            roundedQ = -roundedR - roundedS\n        } else if (diffR > diffS) {\n            roundedR = -roundedQ - roundedS\n        } else {\n            roundedS = -roundedQ - roundedR\n        }\n\n        return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n    }\n}\n\nexport function lerpFactory({ Hex }) {\n    /**\n     * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n     * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n     *\n     * @memberof Hex#\n     *\n     * @param   {hex} hex   The other hex (cannot be a {@link point}).\n     * @param   {number} t  A \"parameter\" between 0 and 1.\n     *\n     * @returns {hex}       A new hex (likely with floating point coordinates).\n     *                      Any custom properties are copied.\n     */\n    return function lerp(hex, t) {\n        const q = this.q * (1 - t) + hex.q * t\n        const r = this.r * (1 - t) + hex.r * t\n        return Hex({ ...this, q, r, s: -q - r })\n    }\n}\n\n/**\n * @memberof Hex#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n *                  Useful for interpolating in a consistent direction.\n */\nexport function nudge() {\n    return this.add(EPSILON)\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n    return `${this.x},${this.y}`\n}\n","import { isObject, isNumber, isArray } from 'axis.js'\n\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport const staticMethods = {\n    thirdCoordinate: statics.thirdCoordinate\n}\n\nexport default function extendHexFactory({ ensureXY, Point }) {\n    /**\n     * @function extendHex\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create custom hexes by extending the default Hex prototype.\n     *\n     * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n     * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n     *\n     * @todo validate orientation, size, origin\n     * @todo warn when properties are overriden\n     *\n     * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n     *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n     *\n     * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({\n     *     size: 50,\n     *     orientation: 'flat',\n     *     customProperty: `I'm custom ðŸ˜ƒ`,\n     *     customMethod() {\n     *         return `${this.customProperty} and called from a custom method ðŸ˜Ž`\n     *     }\n     * })\n     * const hex = Hex(5, -1)\n     *\n     * hex.coordinates()    // { x: 5, y: -1 }\n     * hex.size             // 50\n     * hex.customProperty   // I'm custom ðŸ˜ƒ\n     * hex.customMethod()   // I'm custom ðŸ˜ƒ and called from a custom method ðŸ˜Ž\n     *\n     * // every hex created with Hex() shares these properties:\n     * const hex2 = Hex(3, 0)\n     * hex2.size            // 50\n     * hex2.customProperty  // I'm custom ðŸ˜ƒ\n     *\n     * // to set properties on individual hexes, pass them to Hex():\n     * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake ðŸ˜Œ` })\n     * hex3.instanceProperty    // I'm a unique snowflake ðŸ˜Œ\n     */\n    return function extendHex(prototype = {}) {\n        const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n        const defaultPrototype = {\n            /**\n             * Used internally for type checking\n             *\n             * @memberof Hex#\n             * @private\n             */\n            __isHoneycombHex: true,\n            /**\n             * Either â¬¢ pointy or â¬£ flat. Defaults to `pointy`.\n             *\n             * @memberof Hex#\n             * @type {string}\n             * @default 'pointy'\n             */\n            orientation: 'pointy',\n            /**\n             * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n             * Can be anything the {@link Honeycomb.Point} factory accepts.\n             * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n             *\n             * @memberof Hex#\n             * @type {point}\n             * @default 0\n             */\n            origin: 0,\n            /**\n             * A hex's radius or the length of any of its sides. Defaults to `1`.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default 1\n             */\n            size: 1,\n            /**\n             * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n             * Defaults to `-1` (odd offset).\n             * See {@link OFFSET} for details.\n             * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n             *\n             * @memberof Hex#\n             * @type {number}\n             * @default -1\n             * @see OFFSET\n             */\n            offset: -1,\n            /**\n             * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get q() { return this.cartesianToCube(this).q },\n            /**\n             * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get r() { return this.cartesianToCube(this).r },\n            /**\n             * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n             *\n             * @memberof Hex#\n             * @type {number}\n             */\n            get s() { return this.cartesianToCube(this).s },\n\n            // methods:\n            add: methods.addFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#coordinates}.\n             * @memberof Hex#\n             * @instance\n             */\n            cartesian: methods.coordinates,\n            cartesianToCube,\n            center: methods.centerFactory({ Point }),\n            coordinates: methods.coordinates,\n            corners: methods.cornersFactory({ Point }),\n            cube: methods.cube,\n            cubeToCartesian: methods.cubeToCartesian,\n            distance: methods.distance,\n            equals: methods.equalsFactory({ Point }),\n            fromPoint: methods.fromPointFactory({ Point, Hex }),\n            height: methods.height,\n            isFlat: methods.isFlat,\n            isPointy: methods.isPointy,\n            lerp: methods.lerpFactory({ Hex }),\n            nudge: methods.nudge,\n            oppositeCornerDistance: methods.oppositeCornerDistance,\n            oppositeSideDistance: methods.oppositeSideDistance,\n            round: methods.roundFactory({ Hex }),\n            set: methods.setFactory({ Hex }),\n            subtract: methods.subtractFactory({ Hex, Point }),\n            /**\n             * Alias for {@link Hex#cubeToCartesian}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCartesian: methods.cubeToCartesian,\n            /**\n             * Alias for {@link Hex#cartesianToCube}.\n             * @memberof Hex#\n             * @instance\n             */\n            toCube: cartesianToCube,\n            toPoint: methods.toPointFactory({ Point }),\n            toString: methods.toString,\n            width: methods.width\n        }\n        const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n        // ensure origin is a point\n        finalPrototype.origin = Point(finalPrototype.origin)\n\n        Object.assign(Hex, staticMethods)\n\n        /**\n         * @function Hex\n         *\n         * @description\n         * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n         *\n         * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n         *\n         * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n         *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n         *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n         *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n         * @param {number} [xOrProps.x=]                    The x coordinate.\n         * @param {number} [xOrProps.y=]                    The y coordinate.\n         * @param {number} [y=]                             The y coordinate.\n         * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n         *\n         * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n         *\n         * @example\n         * const Hex = Honeycomb.extendHex()\n         *\n         * // passing numbers:\n         * Hex()                        // { x: 0, y: 0 }\n         * Hex(1)                       // { x: 1, y: 1 }\n         * Hex(1, 2)                    // { x: 1, y: 2 }\n         *\n         * // passing an object with cartesian coordinates:\n         * Hex({})                      // { x: 0, y: 0 }\n         * Hex({ x: 1 })                // { x: 1, y: 1 }\n         * Hex({ y: 2 })                // { x: 2, y: 2 }\n         * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n         *\n         * // passing an object with cube coordinates:\n         * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n         * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n         *\n         * // passing an array:\n         * Hex([])                      // { x: 0, y: 0 }\n         * Hex([1])                     // { x: 1, y: 1 }\n         * Hex([1, 2])                  // { x: 1, y: 2 }\n         *\n         * // custom properties:\n         * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n         * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n         *\n         * // cloning a hex:\n         * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n         * const clone = Hex(someHex)   // { x: 4, y: -2 }\n         * someHex === clone            // false\n         */\n        function Hex(xOrProps, y, customProps = {}) {\n            let x\n\n            if (isObject(xOrProps)) {\n                let { q, r, s, ...rest } = xOrProps\n\n                if (isNumber(q) || isNumber(r) || isNumber(s)) {\n                    if (q + r + s !== 0) {\n                        throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n                    }\n\n                    ({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n                } else {\n                    ({ x, y } = xOrProps)\n                }\n\n                customProps = rest\n            } else if (isArray(xOrProps)) {\n                [x, y] = xOrProps\n                // ignore all arguments except xOrProps\n                customProps = {}\n            } else {\n                x = xOrProps\n            }\n\n            /**\n             * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n             *\n             * @typedef {Object} hex\n             * @property {number} x Cartesian x coordinate.\n             * @property {number} y Cartesian y coordinate.\n             */\n            return Object.assign(\n                // the prototype has to be attached here, else Grid's shape methods break ðŸ™\n                Object.create(finalPrototype),\n                Object.assign(customProps, ensureXY(x, y))\n            )\n        }\n\n        return Hex\n    }\n}\n","import { isString } from 'axis.js'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n    /**\n     * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link Hex#fromPoint}\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ size: 50 })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * const Point = Honeycomb.Point\n     *\n     * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n     * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n     * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n     * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n     */\n    return function pointToHex(pointOrX, y) {\n        return Hex().fromPoint(pointOrX, y)\n    }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) â–±.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n     */\n    return function parallelogram({\n        width,\n        height,\n        start,\n        direction = 1,\n        /**\n         * Callback of a {@link Grid} shape method.\n         * Gets called for each hex that's about to be added to the grid.\n         *\n         * @callback onCreate\n         * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n         * @param {grid} grid   The grid (for as far as it's created).\n         * @returns {void}      Nothing.\n         */\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: ['q', 'r', 's'],\n            3: ['r', 's', 'q'],\n            5: ['s', 'q', 'r']\n        }\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let first = 0; first < width; first++) {\n            for (let second = 0; second < height; second++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) â–³.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.size                 The side length (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n     * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a triangle arrangement.\n     */\n    return function triangle({\n        size,\n        start,\n        direction = 1,\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n        // TODO: validate direction\n        const DIRECTIONS = {\n            1: {\n                rStart: () => 0,\n                rEnd: q => size - q\n            },\n            5: {\n                rStart: q => size - q,\n                rEnd: () => size + 1\n            }\n        }\n        const { rStart, rEnd } = DIRECTIONS[direction]\n        const grid = new Grid()\n\n        for (let q = 0; q < size; q++) {\n            for (let r = rStart(q); r < rEnd(q); r++) {\n                const hex = Hex(start.cubeToCartesian({\n                    q: q + start.q,\n                    r: r + start.r,\n                    s: -q - r + start.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n    /**\n     * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) â¬¡.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n     * @param {hex} [options.center=Hex(0)]         The center hex.\n     *                                              Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n     */\n    return function hexagon({\n        radius,\n        center,\n        onCreate = () => { }\n    }) {\n        center = Hex(center)\n\n        const grid = new Grid()\n\n        for (let q = -radius; q <= radius; q++) {\n            const startR = Math.max(-radius, -q - radius)\n            const endR = Math.min(radius, -q + radius)\n\n            for (let r = startR; r <= endR; r++) {\n                const hex = Hex(center.cubeToCartesian({\n                    q: q + center.q,\n                    r: r + center.r,\n                    s: -q - r + center.s\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n    /**\n     * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) â–­.\n     *\n     * @memberof Grid\n     * @static\n     * @method\n     * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n     *\n     * @todo Validate params\n     * @todo Move duplicate code to util\n     *\n     * @param {Object} options                      An options object.\n     * @param {number} options.width                The width (in hexes).\n     * @param {number} options.height               The height (in hexes).\n     * @param {hex} [options.start=Hex(0)]          The start hex.\n     * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n     * The direction (from the start hex) in which to create the shape.\n     * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n     * Each direction corresponds to a different arrangement of hexes.\n     * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n     *\n     * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n     */\n    return function rectangle({\n        width,\n        height,\n        start,\n        direction = Hex().isPointy() ? 0 : 1, // E or S\n        onCreate = () => { }\n    }) {\n        start = Hex(start)\n\n        if (isString(direction)) {\n            direction = compassToNumberDirection(direction, start.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n            direction = signedModulo(direction, 6)\n        }\n\n        const DIRECTIONS = [\n            ['q', 'r', 's'],\n            ['r', 'q', 's'],\n            ['r', 's', 'q'],\n            ['s', 'r', 'q'],\n            ['s', 'q', 'r'],\n            ['q', 's', 'r']\n        ]\n        const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n        const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n        const grid = new Grid()\n\n        for (let second = 0; second < secondStop; second++) {\n            const secondOffset = offsetFromZero(start.offset, second)\n\n            for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n                const hex = Hex(start.cubeToCartesian({\n                    [firstCoordinate]: first + start[firstCoordinate],\n                    [secondCoordinate]: second + start[secondCoordinate],\n                    [thirdCoordinate]: -first - second + start[thirdCoordinate]\n                }))\n                onCreate(hex, grid)\n                grid.push(hex)\n            }\n        }\n\n        return grid\n    }\n}\n","import { isString, isNumber } from 'axis.js'\n\nimport { DIRECTION_COORDINATES, DIAGONAL_DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n    if (isNumber(keyOrPoint)) {\n        return this[keyOrPoint]\n    } else {\n        return this[this.indexOf(keyOrPoint)]\n    }\n}\n\nexport function setFactory({ isValidHex }) {\n    /**\n     * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n     *\n     * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n     * If the new hex is invalid, nothing changes.\n     *\n     * @memberof Grid#\n     * @instance\n     *\n     * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n     * @param {hex} newHex                  The replacing hex.\n     *\n     * @returns {grid}                      Itself.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n     *\n     * // replace a hex:\n     * grid.set(0, Hex(1, 1))\n     * grid                         // [ { x: 1, y: 1 } ]\n     * // the target hex can also be a point:\n     * grid.set([1, 1], Hex(2, 2))\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // invalid replace values are ignored:\n     * grid.set(0, 'invalid')\n     * grid                         // [ { x: 2, y: 2 } ]\n     *\n     * // when the target hex isn't present in the grid, the replacing hex is added instead:\n     * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n     * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n     */\n    return function set(keyOrPoint, newHex) {\n        if (!isValidHex(newHex)) {\n            return this\n        }\n\n        const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n        if (index < 0) {\n            this.push(newHex)\n        } else {\n            this[index] = newHex\n        }\n\n        return this\n    }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n    const distance = firstHex.distance(lastHex)\n    const step = 1.0 / Math.max(distance, 1)\n    let hexes = []\n\n    for (let i = 0; i <= distance; i++) {\n        const hex = firstHex.nudge().lerp(lastHex.nudge(), step * i).round()\n        hexes.push(this.get(hex))\n    }\n\n    return hexes\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n    /**\n     * @memberof Grid#\n     * @instance\n     * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n     *\n     * @param {hex} hex\n     * A hex to get 1 or more neighbors from.\n     * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n     * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n     * @param {boolean} [diagonal=false]\n     * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n     *\n     * @returns {hex[]}\n     * An array of 0 up to 6 neighboring hexes. Only hexes that are present in the grid are returned.\n     *\n     * @throws {Error} When no valid hex is passed.\n     * @throws {Error} When the direction is invalid for the hex.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n     * const Grid = Honeycomb.defineGrid(Hex)\n     * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n     * const grid = Grid.hexagon({ radius: 1 })\n     *\n     * // all neighbors:\n     * grid.neighborsOf(Hex())          // [\n     *                                  //    { x: 1, y: 0 },\n     *                                  //    { x: 0, y: 1 },\n     *                                  //    { x: -1, y: 1 },\n     *                                  //    { x: -1, y: 0 },\n     *                                  //    { x: -1, y: -1 },\n     *                                  //    { x: 0, y: -1 },\n     *                                  // ]\n     * // specific neighbor:\n     * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n     * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n     *\n     * // multiple neighbors:\n     * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     *\n     * grid.neighborsOf(Hex(), [1, 2])          // [\n     *                                          //    { x: 0, y: 1 },\n     *                                          //    { x: -1, y: 1 }\n     *                                          // ]\n     * // diagonal neighbor:\n     * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n     *\n     * // only returns hexes that exist in the grid:\n     * grid.neighborsOf(Hex(-1, -1), 'NW')      // []\n     */\n    return function neighborsOf(hex, directions = 'all', diagonal = false) {\n        if (!isValidHex(hex)) {\n            throw new Error(`Invalid hex: ${hex}.`)\n        }\n\n        const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n        if (directions === 'all') {\n            directions = [0, 1, 2, 3, 4, 5]\n        }\n\n        return directions = []\n            // ensure directions is an array\n            .concat(directions)\n            .map(direction => {\n                // todo: move this to a util, also grid/statics.js#277\n                if (isString(direction)) {\n                    direction = compassToNumberDirection(direction, hex.orientation)\n                }\n\n                if (direction < 0 || direction > 5) {\n                    direction = signedModulo(direction, 6)\n                }\n\n                const { q, r } = coordinates[direction]\n                return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n            })\n            .filter(Boolean)\n    }\n}\n","import { isArray } from 'axis.js'\n\nimport { signedModulo, compassToNumberDirection } from '../utils'\nimport * as statics from './statics'\nimport * as methods from './prototype'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n    const { isValidHex } = Grid\n\n    /**\n     * @function defineGrid\n     *\n     * @memberof Honeycomb\n     * @static\n     *\n     * @description\n     * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n     *\n     * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n     *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n     *\n     * @returns {Grid}                          A Grid factory.\n     *\n     * @example\n     * // create a Grid factory that uses the default Hex Factory:\n     * const Grid = Honeycomb.defineGrid()\n     * const hex = Grid.Hex()\n     * hex.size     // 1\n     *\n     * // create your own Hex factory\n     * const CustomHex = Honeycomb.extendHex({ size: 10, custom: 'ðŸ¤“' })\n     * // â€¦and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n     * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n     * const customHex = CustomGrid.Hex()\n     * hex.size     // 10\n     * hex.custom   // ðŸ¤“\n     */\n    return function defineGrid(Hex = extendHex()) {\n        // static properties\n        Object.assign(GridFactory, {\n            /**\n             * The {@link Hex} factory the Grid factory was created with.\n             * @memberof Grid\n             * @static\n             * @function\n             */\n            // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n            // it could cause this:\n            // function methodThatBindsThis() {\n            //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n            // }\n            // which is caused by the following line:\n            Hex,\n\n            // methods\n            /**\n             * @memberof Grid\n             * @static\n             * @method\n             *\n             * @param {*} value     Any value.\n             * @returns {boolean}   Whether the passed value is a valid hex.\n             */\n            isValidHex,\n            pointToHex: statics.pointToHexFactory({ Point, Hex }),\n            parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n            triangle: statics.triangleFactory({ Grid, Hex }),\n            hexagon: statics.hexagonFactory({ Grid, Hex }),\n            rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo })\n        })\n\n        // prototype properties\n        Object.assign(\n            Grid.prototype,\n            {\n                // methods\n                get: methods.get,\n                hexesBetween: methods.hexesBetween,\n                neighborsOf: methods.neighborsOfFactory({\n                    isValidHex,\n                    signedModulo,\n                    compassToNumberDirection\n                }),\n                set: methods.setFactory({ isValidHex })\n            }\n        )\n\n        /**\n         * @function Grid\n         *\n         * @description\n         * A function to create hex {@link grid}s and perform various operations on them.\n         *\n         * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n         * It can also be called with 1 or more hexes or an array of hexes to construct/clone a {@link grid} containing those hexes.\n         *\n         * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n         *\n         * @param {(hex[]|hex)} [arrayOrHex]    An array or a hex. Any invalid hexes are filtered out.\n         * @param {...hex} [hexes]              More hexes. Any invalid hexes are filtered out.\n         *\n         * @returns {grid}                      A grid instance containing only valid hexes.\n         *\n         * @example\n         * const Grid = Honeycomb.defineGrid()\n         * // the Hex factory used by the Grid to produce hexes is available as a property\n         * const Hex = Grid.Hex\n         *\n         * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n         *\n         * // invalid hexes are filtered out:\n         * Grid('no hex', { x: 3, y: -1 })  // []\n         * Grid(['no hex', Hex(1, -1)])     // [{ x: 1, y: -1 }]\n         *\n         * // clone a grid:\n         * const grid = Grid(Hex(), Hex(1), Hex(2))\n         * const clonedGrid = Grid(grid)    // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n         * grid === clonedGrid              // false\n         */\n        function GridFactory(arrayOrHex, ...hexes) {\n            if (isArray(arrayOrHex)) {\n                hexes = arrayOrHex\n            } else {\n                hexes.unshift(arrayOrHex)\n            }\n\n            /**\n             * @typedef {Object} grid\n             * @extends Array\n             *\n             * @property {number} length    Amount of hexes in the grid.\n             */\n            return new Grid(...hexes.filter(isValidHex))\n        }\n\n        return GridFactory\n    }\n}\n","export function addFactory({ Point }) {\n    /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n    return function add(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x + x, this.y + y)\n    }\n}\n\nexport function subtractFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The difference between the passed point's coordinates and the current point's.\n     */\n    return function subtract(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x - x, this.y - y)\n    }\n}\n\nexport function multiplyFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n     */\n    return function multiply(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x * x, this.y * y)\n    }\n}\n\nexport function divideFactory({ Point }) {\n    /**\n     * @memberof Point#\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The division of the current point's coordinates and the passed point's.\n     */\n    return function divide(pointOrX, y) {\n        let x\n        ({ x, y } = Point(pointOrX, y))\n        return Point(this.x / x, this.y / y)\n    }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n    const prototype = {\n        add: methods.addFactory({ Point }),\n        subtract: methods.subtractFactory({ Point }),\n        multiply: methods.multiplyFactory({ Point }),\n        divide: methods.divideFactory({ Point })\n    }\n\n    /**\n     * Factory function for creating two-dimensional points.\n     *\n     * @function Point\n     *\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}                             A point.\n     *\n     * @example\n     * const Point = Honeycomb.Point\n     *\n     * Point()                  // { x: 0, y: 0 }\n     * Point(1)                 // { x: 1, y: 1 }\n     * Point(1, 2)              // { x: 1, y: 2 }\n     *\n     * Point([])                // { x: 0, y: 0 }\n     * Point([1])               // { x: 1, y: 1 }\n     * Point([1, 2])            // { x: 1, y: 2 }\n     *\n     * Point({})                // { x: 0, y: 0 }\n     * Point({ x: 1 })          // { x: 1, y: 1 }\n     * Point({ y: 2 })          // { x: 2, y: 2 }\n     * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n     */\n    function Point(pointOrX, y) {\n        let coordinates\n        /**\n         * An object with just an `x` and a `y` property.\n         *\n         * Create your own:\n         * ```javascript\n         * const point = { x: 1, y: 2 }\n         * ```\n         *\n         * Or use the included {@link Point} factory:\n         * ```javascript\n         * const point = Honeycomb.Point(1, 2)\n         * ```\n         *\n         * @typedef {Object} point\n         * @property {number} x (horizontal) x coordinate\n         * @property {number} y (vertical) y coordinate\n         */\n\n        if (isNumber(pointOrX)) {\n            coordinates = ensureXY(pointOrX, y)\n        } else if (isArray(pointOrX)) {\n            coordinates = ensureXY(...pointOrX)\n        } else if (isObject(pointOrX)) {\n            coordinates = ensureXY(pointOrX.x, pointOrX.y)\n        } else {\n            coordinates = ensureXY(0)\n        }\n\n        return Object.assign(\n            Object.create(prototype),\n            coordinates\n        )\n    }\n\n    return Point\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n    /**\n     * @private\n     * @param {*} value     Any value.\n     * @returns {boolean}   Whether the passed value is a valid hex.\n     */\n    static isValidHex(value) {\n        return (value || {}).__isHoneycombHex === true\n    }\n\n    /**\n     * @memberof Grid#\n     * @override\n     * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n     *\n     * @returns {TypeError} An error.\n     */\n    fill() {\n        throw new TypeError('Grid.prototype.fill is not implemented')\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n     * but searches the passed hex (which can also be a {@link point}.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *\n     * @returns {boolean}               Whether the hex is included in the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n     *\n     * grid.includes(Hex(0))        // true\n     * grid.includes([0, 0])        // true\n     * grid.includes(Hex(0), 1)     // false\n     * grid.includes(Hex(5, 7))     // false\n     */\n    includes(point, fromIndex = 0) {\n        return !!(this.indexOf(point, fromIndex) + 1)\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point             The coordinates to search for.\n     * @param {number} [fromIndex=0]    Optional index to start searching.\n     *                                  If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.indexOf(Hex(0))     // 0\n     * grid.indexOf([0, 0])     // 0\n     * grid.indexOf(Hex(0), 1)  // 2\n     * grid.indexOf(Hex(5, 7))  // -1\n     */\n    indexOf(point, fromIndex = 0) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = Math.max(i >= 0 ? i : length + i, 0)\n\n        for (i; i < length; i++) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n     * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n     *\n     * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n     * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {point} point                 The coordinates to search for.\n     * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n     *                                      If negative, it is taken as the offset from the end of the grid.\n     *\n     * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid(Hex(0), Hex(1), Hex(0))\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 1 },\n     * //    { x: 0, y: 0 }\n     * // ]\n     *\n     * grid.lastIndexOf(Hex(0))     // 2\n     * grid.lastIndexOf([0, 0])     // 2\n     * grid.lastIndexOf(Hex(0), 1)  // 0\n     * grid.lastIndexOf(Hex(5, 7))  // -1\n     */\n    lastIndexOf(point, fromIndex = this.length - 1) {\n        const { length } = this\n        let i = Number(fromIndex)\n\n        point = Point(point)\n        i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n        for (i; i >= 0; i--) {\n            if (this[i].equals(point)) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.push(Hex(1))            // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.push('invalid')         // 2\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n     */\n    push(...hexes) {\n        return super.push(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {number} start                        Index at which to start changing the grid.\n     * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n     * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n     *\n     * @returns {hex[]}                             A grid with the deleted hexes (if any).\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     * const grid = Grid.rectangle({ width: 2, height: 1 })\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 0, y: 1 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     *\n     * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n     *\n     * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n     * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n     *\n     * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n     * grid\n     * // [\n     * //    { x: 0, y: 0 },\n     * //    { x: 1, y: 0 },\n     * //    { x: 2, y: 2 },\n     * //    { x: 1, y: 1 }\n     * // ]\n     */\n    splice(start, deleteCount, ...hexes) {\n        // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n        // this is not according to spec: it should delete all hexes (starting from `start`)\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n        if (deleteCount == null) {\n            return super.splice(start)\n        }\n\n        return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n     * but filters out any passed invalid hexes.\n     *\n     * @memberof Grid#\n     * @override\n     *\n     * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n     *\n     * @returns {number}        The new length of the grid.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * const Hex = Grid.Hex\n     *\n     * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n     * grid.unshift(Hex(1))         // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     *\n     * grid.unshift('invalid')      // 2\n     * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n     */\n    unshift(...hexes) {\n        return super.unshift(...hexes.filter(Grid.isValidHex))\n    }\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat|Array#concat}.\n     * @memberof Grid#\n     * @method concat\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/copyWithin|Array#copyWithin}.\n     * @memberof Grid#\n     * @method copyWithin\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries|Array#entries}.\n     * @memberof Grid#\n     * @method entries\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/every|Array#every}.\n     * @memberof Grid#\n     * @method every\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter|Array#filter}.\n     * @memberof Grid#\n     * @method filter\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find|Array#find}.\n     * @memberof Grid#\n     * @method find\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/findIndex|Array#findIndex}.\n     * @memberof Grid#\n     * @method findIndex\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach|Array#forEach}.\n     * @memberof Grid#\n     * @method forEach\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/join|Array#join}.\n     * @memberof Grid#\n     * @method join\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/keys|Array#keys}.\n     * @memberof Grid#\n     * @method keys\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map|Array#map}.\n     * @memberof Grid#\n     * @method map\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop|Array#pop}.\n     * @memberof Grid#\n     * @method pop\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce|Array#reduce}.\n     * @memberof Grid#\n     * @method reduce\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight|Array#reduceRight}.\n     * @memberof Grid#\n     * @method reduceRight\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reverse|Array#reverse}.\n     * @memberof Grid#\n     * @method reverse\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift|Array#shift}.\n     * @memberof Grid#\n     * @method shift\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/some|Array#some}.\n     * @memberof Grid#\n     * @method some\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort|Array#sort}.\n     * @memberof Grid#\n     * @method sort\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toLocaleString|Array#toLocaleString}.\n     * @memberof Grid#\n     * @method toLocaleString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/toString|Array#toString}.\n     * @memberof Grid#\n     * @method toString\n     * @instance\n     */\n\n    /**\n     * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/values|Array#values}.\n     * @memberof Grid#\n     * @method values\n     * @instance\n     */\n}\n","import { ensureXY } from './utils'\nimport extendHexFactory from './hex'\nimport defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport PointFactory from './point'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport {\n    extendHex,\n    defineGrid,\n    Point\n}\n"],"names":["factory","axis","types","split","type","Object","prototype","toString","call","this","slice","i","length","self","elem","module","offsetFromZero","offset","distance","signedModulo","dividend","divisor","compassToNumberDirection","value","orientation","test","Error","toLowerCase","toUpperCase","includes","E","SE","SW","W","NW","NE","S","N","ensureXY","x","y","isNumber","thirdCoordinate","firstCoordinate","secondCoordinate","DIRECTION_COORDINATES","q","r","DIAGONAL_DIRECTION_COORDINATES","EPSILON","setFactory","Hex","args","assign","coordinates","cube","s","cubeToCartesian","isPointy","cartesianToCubeFactory","Point","pointOrX","isFlat","oppositeCornerDistance","size","oppositeSideDistance","sqrt3","width","height","cornersFactory","origin","centerFactory","toPointFactory","fromPointFactory","subtract","center","round","addFactory","point","subtractFactory","equalsFactory","hex","Math","max","abs","roundFactory","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","lerpFactory","t","nudge","add","staticMethods","statics","extendHexFactory","cartesianToCube","methods","defaultPrototype","finalPrototype","xOrProps","customProps","isObject","rest","isArray","create","pointToHexFactory","fromPoint","parallelogramFactory","Grid","start","direction","onCreate","grid","first","second","push","triangleFactory","rStart","rEnd","hexagonFactory","radius","startR","endR","min","rectangleFactory","isString","firstStop","secondStop","secondOffset","get","keyOrPoint","indexOf","isValidHex","newHex","index","hexesBetween","firstHex","lastHex","step","hexes","lerp","neighborsOfFactory","directions","diagonal","concat","map","filter","Boolean","defineGridFactory","extendHex","GridFactory","arrayOrHex","unshift","multiplyFactory","divideFactory","PointFactory","Array","__isHoneycombHex","TypeError","fromIndex","Number","equals","super","deleteCount","splice","defineGrid"],"mappings":"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"}