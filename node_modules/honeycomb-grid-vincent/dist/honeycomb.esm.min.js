var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(t,r){return t(r={exports:{}},r.exports),r.exports}var axis=createCommonjsModule(function(t,r){var e;e=function(){var t={},r="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function e(){return Object.prototype.toString.call(this).slice(8,-1)}for(var n=r.length;n--;)t["is"+r[n]]=function(t){return function(r){return e.call(r)===t}}(r[n]);return t},t.exports=e()}),axis_1=axis.isObject,axis_2=axis.isNumber,axis_3=axis.isArray,axis_4=axis.isString;function offsetFromZero(t,r){return r+t*(1&r)>>1}function signedModulo(t,r){return(t%r+r)%r}function compassToNumberDirection(t,r){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(r=r.toLowerCase(),t=t.toUpperCase(),"pointy"===r&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===r&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[r][t]}function ensureXY(t,r){return axis_2(t)||axis_2(r)?axis_2(t)?axis_2(r)||(r=t):t=r:t=r=0,{x:t,y:r}}function thirdCoordinate(t,r){return-t-r}const DIRECTION_COORDINATES=[{q:1,r:0},{q:0,r:1},{q:-1,r:1},{q:-1,r:0},{q:0,r:-1},{q:1,r:-1}],DIAGONAL_DIRECTION_COORDINATES=[{q:2,r:-1},{q:1,r:1},{q:-1,r:2},{q:-2,r:1},{q:-1,r:-1},{q:1,r:-2}],EPSILON={x:1e-6,y:1e-6},sqrt3=Math.sqrt(3);function setFactory({Hex:t}){return function(...r){return Object.assign(this,t(...r))}}function coordinates(){return{x:this.x,y:this.y}}function cube(){return{q:this.q,r:this.r,s:this.s}}function cubeToCartesian({q:t,r:r}){let e,n;return this.isPointy()?(e=t+offsetFromZero(this.offset,r),n=r):(e=t,n=r+offsetFromZero(this.offset,t)),{x:e,y:n}}function cartesianToCubeFactory({Point:t}){return function(r,e){let n,i,o;var s=t(r,e);return n=s.x,e=s.y,this.isPointy()?(i=n-offsetFromZero(this.offset,e),o=e):(i=n,o=e-offsetFromZero(this.offset,n)),{q:i,r:o,s:-i-o}}}function isPointy(){return"pointy"===this.orientation.toLowerCase()}function isFlat(){return"flat"===this.orientation.toLowerCase()}function oppositeCornerDistance(){return 2*this.size}function oppositeSideDistance(){return sqrt3/2*this.oppositeCornerDistance()}function width(){return this.isPointy()?this.oppositeSideDistance():this.oppositeCornerDistance()}function height(){return this.isPointy()?this.oppositeCornerDistance():this.oppositeSideDistance()}function cornersFactory({Point:t}){return function(){const r=this.width(),e=this.height();var n=this.origin;const i=n.x,o=n.y;return this.isPointy()?[t(r-i,.25*e-o),t(r-i,.75*e-o),t(.5*r-i,e-o),t(0-i,.75*e-o),t(0-i,.25*e-o),t(.5*r-i,0-o)]:[t(r-i,.5*e-o),t(.75*r-i,e-o),t(.25*r-i,e-o),t(0-i,.5*e-o),t(.25*r-i,0-o),t(.75*r-i,0-o)]}}function centerFactory({Point:t}){return function(){var r=this.origin;const e=r.x,n=r.y;return t(this.width()/2-e,this.height()/2-n)}}function toPointFactory({Point:t}){return function(){const r=this.q,e=this.r,n=this.size;let i,o;return this.isPointy()?(i=n*sqrt3*(r+e/2),o=3*n/2*e):(i=3*n/2*r,o=n*sqrt3*(e+r/2)),t(i,o)}}function fromPointFactory({Point:t,Hex:r}){return function(e,n){const i=this.size;let o,s,a;var c=t(e,n).subtract(this.center());return o=c.x,n=c.y,this.isPointy()?(s=(o*sqrt3/3-n/3)/i,a=2*n/3/i):(s=2*o/3/i,a=(-o/3+sqrt3/3*n)/i),r({q:s,r:a,s:-s-a}).round()}}function addFactory({Hex:t,Point:r}){return function(e){var n=r(e);const i=n.x,o=n.y;return t(this.x+i,this.y+o,Object.assign({},this))}}function subtractFactory({Hex:t,Point:r}){return function(e){var n=r(e);const i=n.x,o=n.y;return t(this.x-i,this.y-o,Object.assign({},this))}}function equalsFactory({Point:t}){return function(r){var e=t(r);const n=e.x,i=e.y;return this.x===n&&this.y===i}}function distance(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function roundFactory({Hex:t}){return function(){let r=this.q,e=this.r,n=this.s,i=Math.round(r),o=Math.round(e),s=Math.round(n);const a=Math.abs(r-i),c=Math.abs(e-o),u=Math.abs(n-s);return a>c&&a>u?i=-o-s:c>u?o=-i-s:s=-i-o,t(Object.assign({},this,{q:i,r:o,s:s}))}}function lerpFactory({Hex:t}){return function(r,e){const n=this.q*(1-e)+r.q*e,i=this.r*(1-e)+r.r*e;return t(Object.assign({},this,{q:n,r:i,s:-n-i}))}}function nudge(){return this.add(EPSILON)}function toString(){return`${this.x},${this.y}`}var objectWithoutProperties=function(t,r){var e={};for(var n in t)r.indexOf(n)>=0||Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e},slicedToArray=function(){return function(t,r){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return function(t,r){var e=[],n=!0,i=!1,o=void 0;try{for(var s,a=t[Symbol.iterator]();!(n=(s=a.next()).done)&&(e.push(s.value),!r||e.length!==r);n=!0);}catch(t){i=!0,o=t}finally{try{!n&&a.return&&a.return()}finally{if(i)throw o}}return e}(t,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}();const staticMethods={thirdCoordinate:thirdCoordinate};function extendHexFactory({ensureXY:t,Point:r}){return function(e={}){const n=cartesianToCubeFactory({Point:r}),i={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:1,offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:addFactory({Hex:s,Point:r}),cartesian:coordinates,cartesianToCube:n,center:centerFactory({Point:r}),coordinates:coordinates,corners:cornersFactory({Point:r}),cube:cube,cubeToCartesian:cubeToCartesian,distance:distance,equals:equalsFactory({Point:r}),fromPoint:fromPointFactory({Point:r,Hex:s}),height:height,isFlat:isFlat,isPointy:isPointy,lerp:lerpFactory({Hex:s}),nudge:nudge,oppositeCornerDistance:oppositeCornerDistance,oppositeSideDistance:oppositeSideDistance,round:roundFactory({Hex:s}),set:setFactory({Hex:s}),subtract:subtractFactory({Hex:s,Point:r}),toCartesian:cubeToCartesian,toCube:n,toPoint:toPointFactory({Point:r}),toString:toString,width:width},o=Object.assign(i,e);function s(r,e,n={}){let i;if(axis_1(r)){let t=r.q,a=r.r,c=r.s,u=objectWithoutProperties(r,["q","r","s"]);if(axis_2(t)||axis_2(a)||axis_2(c)){if(t+a+c!==0)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${a}, s: ${c}, sum: ${t+a+c}.`);var s=o.cubeToCartesian({q:t,r:a,s:c});i=s.x,e=s.y}else i=r.x,e=r.y;n=u}else if(axis_3(r)){var a=slicedToArray(r,2);i=a[0],e=a[1],n={}}else i=r;return Object.assign(Object.create(o),Object.assign(n,t(i,e)))}return o.origin=r(o.origin),Object.assign(s,staticMethods),s}}function pointToHexFactory({Hex:t}){return function(r,e){return t().fromPoint(r,e)}}function parallelogramFactory({Grid:t,Hex:r}){return function({width:e,height:n,start:i,direction:o=1,onCreate:s=(()=>{})}){i=r(i);var a=slicedToArray({1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[o],3);const c=a[0],u=a[1],f=a[2],h=new t;for(let t=0;t<e;t++)for(let e=0;e<n;e++){const n=r(i.cubeToCartesian({[c]:t+i[c],[u]:e+i[u],[f]:-t-e+i[f]}));s(n,h),h.push(n)}return h}}function triangleFactory({Grid:t,Hex:r}){return function({size:e,start:n,direction:i=1,onCreate:o=(()=>{})}){n=r(n);var s={1:{rStart:()=>0,rEnd:t=>e-t},5:{rStart:t=>e-t,rEnd:()=>e+1}}[i];const a=s.rStart,c=s.rEnd,u=new t;for(let t=0;t<e;t++)for(let e=a(t);e<c(t);e++){const i=r(n.cubeToCartesian({q:t+n.q,r:e+n.r,s:-t-e+n.s}));o(i,u),u.push(i)}return u}}function hexagonFactory({Grid:t,Hex:r}){return function({radius:e,center:n,onCreate:i=(()=>{})}){n=r(n);const o=new t;for(let t=-e;t<=e;t++){const s=Math.max(-e,-t-e),a=Math.min(e,-t+e);for(let e=s;e<=a;e++){const s=r(n.cubeToCartesian({q:t+n.q,r:e+n.r,s:-t-e+n.s}));i(s,o),o.push(s)}}return o}}function rectangleFactory({Grid:t,Hex:r,compassToNumberDirection:e,signedModulo:n}){return function({width:i,height:o,start:s,direction:a=(r().isPointy()?0:1),onCreate:c=(()=>{})}){s=r(s),axis_4(a)&&(a=e(a,s.orientation)),(a<0||a>5)&&(a=n(a,6));var u=slicedToArray([["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],3);const f=u[0],h=u[1],d=u[2];var l=s.isPointy()?[i,o]:[o,i],x=slicedToArray(l,2);const y=x[0],p=x[1],b=new t;for(let t=0;t<p;t++){const e=offsetFromZero(s.offset,t);for(let n=-e;n<y-e;n++){const e=r(s.cubeToCartesian({[f]:n+s[f],[h]:t+s[h],[d]:-n-t+s[d]}));c(e,b),b.push(e)}}return b}}function get$1(t){return axis_2(t)?this[t]:this[this.indexOf(t)]}function setFactory$1({isValidHex:t}){return function(r,e){if(!t(e))return this;const n=axis_2(r)?r:this.indexOf(r);return n<0?this.push(e):this[n]=e,this}}function hexesBetween(t,r){const e=t.distance(r),n=1/Math.max(e,1);let i=[];for(let o=0;o<=e;o++){const e=t.nudge().lerp(r.nudge(),n*o).round();i.push(this.get(e))}return i}function neighborsOfFactory({isValidHex:t,signedModulo:r,compassToNumberDirection:e}){return function(n,i="all",o=!1){if(!t(n))throw new Error(`Invalid hex: ${n}.`);const s=o?DIAGONAL_DIRECTION_COORDINATES:DIRECTION_COORDINATES;return"all"===i&&(i=[0,1,2,3,4,5]),[].concat(i).map(t=>{axis_4(t)&&(t=e(t,n.orientation)),(t<0||t>5)&&(t=r(t,6));var i=s[t];const o=i.q,a=i.r;return this.get(n.cubeToCartesian({q:n.q+o,r:n.r+a}))}).filter(Boolean)}}function defineGridFactory({extendHex:t,Grid:r,Point:e}){const n=r.isValidHex;return function(i=t()){function o(t,...e){return axis_3(t)?e=t:e.unshift(t),new r(...e.filter(n))}return Object.assign(o,{Hex:i,isValidHex:n,pointToHex:pointToHexFactory({Point:e,Hex:i}),parallelogram:parallelogramFactory({Grid:r,Hex:i}),triangle:triangleFactory({Grid:r,Hex:i}),hexagon:hexagonFactory({Grid:r,Hex:i}),rectangle:rectangleFactory({Grid:r,Hex:i,compassToNumberDirection:compassToNumberDirection,signedModulo:signedModulo})}),Object.assign(r.prototype,{get:get$1,hexesBetween:hexesBetween,neighborsOf:neighborsOfFactory({isValidHex:n,signedModulo:signedModulo,compassToNumberDirection:compassToNumberDirection}),set:setFactory$1({isValidHex:n})}),o}}function addFactory$1({Point:t}){return function(r,e){let n;var i=t(r,e);return n=i.x,e=i.y,t(this.x+n,this.y+e)}}function subtractFactory$1({Point:t}){return function(r,e){let n;var i=t(r,e);return n=i.x,e=i.y,t(this.x-n,this.y-e)}}function multiplyFactory({Point:t}){return function(r,e){let n;var i=t(r,e);return n=i.x,e=i.y,t(this.x*n,this.y*e)}}function divideFactory({Point:t}){return function(r,e){let n;var i=t(r,e);return n=i.x,e=i.y,t(this.x/n,this.y/e)}}function PointFactory({ensureXY:t}){const r={add:addFactory$1({Point:e}),subtract:subtractFactory$1({Point:e}),multiply:multiplyFactory({Point:e}),divide:divideFactory({Point:e})};function e(e,n){let i;return i=axis_2(e)?t(e,n):axis_3(e)?t(...e):axis_1(e)?t(e.x,e.y):t(0),Object.assign(Object.create(r),i)}return e}const Point=PointFactory({ensureXY:ensureXY});class Grid extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,r=0){return!!(this.indexOf(t,r)+1)}indexOf(t,r=0){const e=this.length;let n=Number(r);for(t=Point(t),n=Math.max(n>=0?n:e+n,0);n<e;n++)if(this[n].equals(t))return n;return-1}lastIndexOf(t,r=this.length-1){const e=this.length;let n=Number(r);for(t=Point(t),n=n>=0?Math.min(n,e-1):e+n;n>=0;n--)if(this[n].equals(t))return n;return-1}push(...t){return super.push(...t.filter(Grid.isValidHex))}splice(t,r,...e){return null==r?super.splice(t):super.splice(t,r,...e.filter(Grid.isValidHex))}unshift(...t){return super.unshift(...t.filter(Grid.isValidHex))}}const Point$1=PointFactory({ensureXY:ensureXY}),extendHex=extendHexFactory({ensureXY:ensureXY,Point:Point$1}),defineGrid=defineGridFactory({extendHex:extendHex,Grid:Grid,Point:Point$1});export{extendHex,defineGrid,Point$1 as Point};
//# sourceMappingURL=honeycomb.esm.min.js.map
