var commonjsGlobal = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function createCommonjsModule(t, r) { return t(r = { exports: {} }, r.exports), r.exports } var axis = createCommonjsModule(function (t, r) { var e; e = function () { var t = {}, r = "Array Object String Date RegExp Function Boolean Number Null Undefined".split(" "); function e() { return Object.prototype.toString.call(this).slice(8, -1) } for (var n = r.length; n--;)t["is" + r[n]] = function (t) { return function (r) { return e.call(r) === t } }(r[n]); return t }, t.exports = e() }), axis_1 = axis.isObject, axis_2 = axis.isNumber, axis_3 = axis.isArray, axis_4 = axis.isString; function offsetFromZero(t, r) { return r + t * (1 & r) >> 1 } function signedModulo(t, r) { return (t % r + r) % r } function compassToNumberDirection(t, r) { if (!/^(N|S)?(E|W)?$/i.test(t)) throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`); if (r = r.toLowerCase(), t = t.toUpperCase(), "pointy" === r && ["N", "S"].includes(t)) throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`); if ("flat" === r && ["E", "W"].includes(t)) throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`); return { pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 }, flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 } }[r][t] } function ensureXY(t, r) { return axis_2(t) || axis_2(r) ? axis_2(t) ? axis_2(r) || (r = t) : t = r : t = r = 0, { x: t, y: r } } function thirdCoordinate(t, r) { return -t - r } const DIRECTION_COORDINATES = [{ q: 1, r: 0 }, { q: 0, r: 1 }, { q: -1, r: 1 }, { q: -1, r: 0 }, { q: 0, r: -1 }, { q: 1, r: -1 }], DIAGONAL_DIRECTION_COORDINATES = [{ q: 2, r: -1 }, { q: 1, r: 1 }, { q: -1, r: 2 }, { q: -2, r: 1 }, { q: -1, r: -1 }, { q: 1, r: -2 }], EPSILON = { x: 1e-6, y: 1e-6 }, sqrt3 = Math.sqrt(3); function setFactory({ Hex: t }) { return function (...r) { return Object.assign(this, t(...r)) } } function coordinates() { return { x: this.x, y: this.y } } function cube() { return { q: this.q, r: this.r, s: this.s } } function cubeToCartesian({ q: t, r: r }) { let e, n; return this.isPointy() ? (e = t + offsetFromZero(this.offset, r), n = r) : (e = t, n = r + offsetFromZero(this.offset, t)), { x: e, y: n } } function cartesianToCubeFactory({ Point: t }) { return function (r, e) { let n, i, o; var s = t(r, e); return n = s.x, e = s.y, this.isPointy() ? (i = n - offsetFromZero(this.offset, e), o = e) : (i = n, o = e - offsetFromZero(this.offset, n)), { q: i, r: o, s: -i - o } } } function isPointy() { return "pointy" === this.orientation.toLowerCase() } function isFlat() { return "flat" === this.orientation.toLowerCase() } function oppositeCornerDistance() { return 2 * this.size } function oppositeSideDistance() { return sqrt3 / 2 * this.oppositeCornerDistance() } function width() { return this.isPointy() ? this.oppositeSideDistance() : this.oppositeCornerDistance() } function height() { return this.isPointy() ? this.oppositeCornerDistance() : this.oppositeSideDistance() } function cornersFactory({ Point: t }) { return function () { const r = this.width(), e = this.height(); var n = this.origin; const i = n.x, o = n.y; return this.isPointy() ? [t(r - i, .25 * e - o), t(r - i, .75 * e - o), t(.5 * r - i, e - o), t(0 - i, .75 * e - o), t(0 - i, .25 * e - o), t(.5 * r - i, 0 - o)] : [t(r - i, .5 * e - o), t(.75 * r - i, e - o), t(.25 * r - i, e - o), t(0 - i, .5 * e - o), t(.25 * r - i, 0 - o), t(.75 * r - i, 0 - o)] } } function centerFactory({ Point: t }) { return function () { var r = this.origin; const e = r.x, n = r.y; return t(this.width() / 2 - e, this.height() / 2 - n) } } function toPointFactory({ Point: t }) { return function () { const r = this.q, e = this.r, n = this.size; let i, o; return this.isPointy() ? (i = n * sqrt3 * (r + e / 2), o = 3 * n / 2 * e) : (i = 3 * n / 2 * r, o = n * sqrt3 * (e + r / 2)), t(i, o) } } function fromPointFactory({ Point: t, Hex: r }) { return function (e, n) { const i = this.size; let o, s, a; var c = t(e, n).subtract(this.center()); return o = c.x, n = c.y, this.isPointy() ? (s = (o * sqrt3 / 3 - n / 3) / i, a = 2 * n / 3 / i) : (s = 2 * o / 3 / i, a = (-o / 3 + sqrt3 / 3 * n) / i), r({ q: s, r: a, s: -s - a }).round() } } function addFactory({ Hex: t, Point: r }) { return function (e) { var n = r(e); const i = n.x, o = n.y; return t(this.x + i, this.y + o, Object.assign({}, this)) } } function subtractFactory({ Hex: t, Point: r }) { return function (e) { var n = r(e); const i = n.x, o = n.y; return t(this.x - i, this.y - o, Object.assign({}, this)) } } function equalsFactory({ Point: t }) { return function (r) { var e = t(r); const n = e.x, i = e.y; return this.x === n && this.y === i } } function distance(t) { return Math.max(Math.abs(this.q - t.q), Math.abs(this.r - t.r), Math.abs(this.s - t.s)) } function roundFactory({ Hex: t }) { return function () { let r = this.q, e = this.r, n = this.s, i = Math.round(r), o = Math.round(e), s = Math.round(n); const a = Math.abs(r - i), c = Math.abs(e - o), u = Math.abs(n - s); return a > c && a > u ? i = -o - s : c > u ? o = -i - s : s = -i - o, t(Object.assign({}, this, { q: i, r: o, s: s })) } } function lerpFactory({ Hex: t }) { return function (r, e) { const n = this.q * (1 - e) + r.q * e, i = this.r * (1 - e) + r.r * e; return t(Object.assign({}, this, { q: n, r: i, s: -n - i })) } } function nudge() { return this.add(EPSILON) } function toString() { return `${this.x},${this.y}` } var objectWithoutProperties = function (t, r) { var e = {}; for (var n in t) r.indexOf(n) >= 0 || Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]); return e }, slicedToArray = function () { return function (t, r) { if (Array.isArray(t)) return t; if (Symbol.iterator in Object(t)) return function (t, r) { var e = [], n = !0, i = !1, o = void 0; try { for (var s, a = t[Symbol.iterator](); !(n = (s = a.next()).done) && (e.push(s.value), !r || e.length !== r); n = !0); } catch (t) { i = !0, o = t } finally { try { !n && a.return && a.return() } finally { if (i) throw o } } return e }(t, r); throw new TypeError("Invalid attempt to destructure non-iterable instance") } }(); const staticMethods = { thirdCoordinate: thirdCoordinate }; function extendHexFactory({ ensureXY: t, Point: r }) { return function (e = {}) { const n = cartesianToCubeFactory({ Point: r }), i = { __isHoneycombHex: !0, orientation: "pointy", origin: 0, size: 1, offset: -1, get q() { return this.cartesianToCube(this).q }, get r() { return this.cartesianToCube(this).r }, get s() { return this.cartesianToCube(this).s }, add: addFactory({ Hex: s, Point: r }), cartesian: coordinates, cartesianToCube: n, center: centerFactory({ Point: r }), coordinates: coordinates, corners: cornersFactory({ Point: r }), cube: cube, cubeToCartesian: cubeToCartesian, distance: distance, equals: equalsFactory({ Point: r }), fromPoint: fromPointFactory({ Point: r, Hex: s }), height: height, isFlat: isFlat, isPointy: isPointy, lerp: lerpFactory({ Hex: s }), nudge: nudge, oppositeCornerDistance: oppositeCornerDistance, oppositeSideDistance: oppositeSideDistance, round: roundFactory({ Hex: s }), set: setFactory({ Hex: s }), subtract: subtractFactory({ Hex: s, Point: r }), toCartesian: cubeToCartesian, toCube: n, toPoint: toPointFactory({ Point: r }), toString: toString, width: width }, o = Object.assign(i, e); function s(r, e, n = {}) { let i; if (axis_1(r)) { let t = r.q, a = r.r, c = r.s, u = objectWithoutProperties(r, ["q", "r", "s"]); if (axis_2(t) || axis_2(a) || axis_2(c)) { if (t + a + c !== 0) throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${a}, s: ${c}, sum: ${t + a + c}.`); var s = o.cubeToCartesian({ q: t, r: a, s: c }); i = s.x, e = s.y } else i = r.x, e = r.y; n = u } else if (axis_3(r)) { var a = slicedToArray(r, 2); i = a[0], e = a[1], n = {} } else i = r; return Object.assign(Object.create(o), Object.assign(n, t(i, e))) } return o.origin = r(o.origin), Object.assign(s, staticMethods), s } } function pointToHexFactory({ Hex: t }) { return function (r, e) { return t().fromPoint(r, e) } } function parallelogramFactory({ Grid: t, Hex: r }) { return function ({ width: e, height: n, start: i, direction: o = 1, onCreate: s = (() => { }) }) { i = r(i); var a = slicedToArray({ 1: ["q", "r", "s"], 3: ["r", "s", "q"], 5: ["s", "q", "r"] }[o], 3); const c = a[0], u = a[1], f = a[2], h = new t; for (let t = 0; t < e; t++)for (let e = 0; e < n; e++) { const n = r(i.cubeToCartesian({ [c]: t + i[c], [u]: e + i[u], [f]: -t - e + i[f] })); s(n, h), h.push(n) } return h } } function triangleFactory({ Grid: t, Hex: r }) { return function ({ size: e, start: n, direction: i = 1, onCreate: o = (() => { }) }) { n = r(n); var s = { 1: { rStart: () => 0, rEnd: t => e - t }, 5: { rStart: t => e - t, rEnd: () => e + 1 } }[i]; const a = s.rStart, c = s.rEnd, u = new t; for (let t = 0; t < e; t++)for (let e = a(t); e < c(t); e++) { const i = r(n.cubeToCartesian({ q: t + n.q, r: e + n.r, s: -t - e + n.s })); o(i, u), u.push(i) } return u } } function hexagonFactory({ Grid: t, Hex: r }) { return function ({ radius: e, center: n, onCreate: i = (() => { }) }) { n = r(n); const o = new t; for (let t = -e; t <= e; t++) { const s = Math.max(-e, -t - e), a = Math.min(e, -t + e); for (let e = s; e <= a; e++) { const s = r(n.cubeToCartesian({ q: t + n.q, r: e + n.r, s: -t - e + n.s })); i(s, o), o.push(s) } } return o } } function rectangleFactory({ Grid: t, Hex: r, compassToNumberDirection: e, signedModulo: n }) { return function ({ width: i, height: o, start: s, direction: a = (r().isPointy() ? 0 : 1), onCreate: c = (() => { }) }) { s = r(s), axis_4(a) && (a = e(a, s.orientation)), (a < 0 || a > 5) && (a = n(a, 6)); var u = slicedToArray([["q", "r", "s"], ["r", "q", "s"], ["r", "s", "q"], ["s", "r", "q"], ["s", "q", "r"], ["q", "s", "r"]][a], 3); const f = u[0], h = u[1], d = u[2]; var l = s.isPointy() ? [i, o] : [o, i], x = slicedToArray(l, 2); const y = x[0], p = x[1], b = new t; for (let t = 0; t < p; t++) { const e = offsetFromZero(s.offset, t); for (let n = -e; n < y - e; n++) { const e = r(s.cubeToCartesian({ [f]: n + s[f], [h]: t + s[h], [d]: -n - t + s[d] })); c(e, b), b.push(e) } } return b } } function get$1(t) { return axis_2(t) ? this[t] : this[this.indexOf(t)] } function setFactory$1({ isValidHex: t }) { return function (r, e) { if (!t(e)) return this; const n = axis_2(r) ? r : this.indexOf(r); return n < 0 ? this.push(e) : this[n] = e, this } } function hexesBetween(t, r) { const e = t.distance(r), n = 1 / Math.max(e, 1); let i = []; for (let o = 0; o <= e; o++) { const e = t.nudge().lerp(r.nudge(), n * o).round(); i.push(this.get(e)) } return i } function neighborsOfFactory({ isValidHex: t, signedModulo: r, compassToNumberDirection: e }) { return function (n, i = "all", o = !1) { if (!t(n)) throw new Error(`Invalid hex: ${n}.`); const s = o ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES; return "all" === i && (i = [0, 1, 2, 3, 4, 5]), [].concat(i).map(t => { axis_4(t) && (t = e(t, n.orientation)), (t < 0 || t > 5) && (t = r(t, 6)); var i = s[t]; const o = i.q, a = i.r; return this.get(n.cubeToCartesian({ q: n.q + o, r: n.r + a })) }).filter(Boolean) } } function defineGridFactory({ extendHex: t, Grid: r, Point: e }) { const n = r.isValidHex; return function (i = t()) { function o(t, ...e) { return axis_3(t) ? e = t : e.unshift(t), new r(...e.filter(n)) } return Object.assign(o, { Hex: i, isValidHex: n, pointToHex: pointToHexFactory({ Point: e, Hex: i }), parallelogram: parallelogramFactory({ Grid: r, Hex: i }), triangle: triangleFactory({ Grid: r, Hex: i }), hexagon: hexagonFactory({ Grid: r, Hex: i }), rectangle: rectangleFactory({ Grid: r, Hex: i, compassToNumberDirection: compassToNumberDirection, signedModulo: signedModulo }) }), Object.assign(r.prototype, { get: get$1, hexesBetween: hexesBetween, neighborsOf: neighborsOfFactory({ isValidHex: n, signedModulo: signedModulo, compassToNumberDirection: compassToNumberDirection }), set: setFactory$1({ isValidHex: n }) }), o } } function addFactory$1({ Point: t }) { return function (r, e) { let n; var i = t(r, e); return n = i.x, e = i.y, t(this.x + n, this.y + e) } } function subtractFactory$1({ Point: t }) { return function (r, e) { let n; var i = t(r, e); return n = i.x, e = i.y, t(this.x - n, this.y - e) } } function multiplyFactory({ Point: t }) { return function (r, e) { let n; var i = t(r, e); return n = i.x, e = i.y, t(this.x * n, this.y * e) } } function divideFactory({ Point: t }) { return function (r, e) { let n; var i = t(r, e); return n = i.x, e = i.y, t(this.x / n, this.y / e) } } function PointFactory({ ensureXY: t }) { const r = { add: addFactory$1({ Point: e }), subtract: subtractFactory$1({ Point: e }), multiply: multiplyFactory({ Point: e }), divide: divideFactory({ Point: e }) }; function e(e, n) { let i; return i = axis_2(e) ? t(e, n) : axis_3(e) ? t(...e) : axis_1(e) ? t(e.x, e.y) : t(0), Object.assign(Object.create(r), i) } return e } const Point = PointFactory({ ensureXY: ensureXY }); class Grid extends Array { static isValidHex(t) { return !0 === (t || {}).__isHoneycombHex } fill() { throw new TypeError("Grid.prototype.fill is not implemented") } includes(t, r = 0) { return !!(this.indexOf(t, r) + 1) } indexOf(t, r = 0) { const e = this.length; let n = Number(r); for (t = Point(t), n = Math.max(n >= 0 ? n : e + n, 0); n < e; n++)if (this[n].equals(t)) return n; return -1 } lastIndexOf(t, r = this.length - 1) { const e = this.length; let n = Number(r); for (t = Point(t), n = n >= 0 ? Math.min(n, e - 1) : e + n; n >= 0; n--)if (this[n].equals(t)) return n; return -1 } push(...t) { return super.push(...t.filter(Grid.isValidHex)) } splice(t, r, ...e) { return null == r ? super.splice(t) : super.splice(t, r, ...e.filter(Grid.isValidHex)) } unshift(...t) { return super.unshift(...t.filter(Grid.isValidHex)) } } const Point$1 = PointFactory({ ensureXY: ensureXY }), extendHex = extendHexFactory({ ensureXY: ensureXY, Point: Point$1 }), defineGrid = defineGridFactory({ extendHex: extendHex, Grid: Grid, Point: Point$1 }); export { extendHex, defineGrid, Point$1 as Point };
//# sourceMappingURL=honeycomb.esm.min.js.map
